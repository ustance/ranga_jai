// This generates all the files in the `src-autogen` folder.  If the Steamworks version has changed,
// it's very likely this will break.  A manual edit after running is almost guaranteed to be necessary.

#import "Basic";
#import "File";
#import "File_Utilities";
#import "String";
#import "Hash_Table";

#load "src/string.jai";
#load "src/json.jai";


steam_api_flat :: "sdk/public/steam/steam_api_flat.h";
steam_api_json :: "sdk/public/steam/steam_api.json";

output_autogen_folder       :: "src-autogen";
output_procs_filename       :: "src-autogen/api_flat_procs.jai";
output_types_filename       :: "src-autogen/api_flat_types.jai";
output_steam_api_filename   :: "src-autogen/steam_api.jai";  // for misc procs not attached to singletons
output_assignments_filename :: "src-autogen/partial_steam_assignments.jai";
output_loads_filename       :: "src-autogen/partial_steam_loads.jai";

Replacement :: struct {
    before : string;
    after  : string;
}

replacements :: Replacement.[
    .{"const ", ""},
    .{"unsigned short", "u16"},
    .{"unsigned int", "u32"},
    .{"ISteamHTMLSurface::", ""},
];

type_replacements :: Replacement.[
    .{"const ", ""},
    .{"unsigned ", "u"},
];

typedef_replacements :: Replacement.[
    .{"char [1024]", "[1024] char"},
    .{"int", "s64"},
    .{"short", "s16"},
    .{"unsigned char [8]", "[8] u8"},
    .{"unsigned char", "u8"},
    .{"unsigned int", "uint"},
    .{"unsigned long long", "u64"},
    .{"unsigned short", "u16"},
    .{"signed char", "s8"},
    .{"long long", "s64"},
    .{"void *", "*void"},
];

const_val_replacements :: Replacement.[
    .{"0xffffffffffffffffull", "0xffffffffffffffff"},
    .{" 16U ", " 16 "},
    .{" 8U ", " 8 "},
    .{" ( uint32 ) ", " cast(uint32) "},
    .{"'d'", "#char \"d\""},
    .{"'e'", "#char \"e\""},
    .{"'v'", "#char \"v\""},
    .{"( SteamItemInstanceID_t )", "cast(SteamItemInstanceID_t)"},
];


procs_builder: String_Builder;
types_builder: String_Builder;
steam_api_top_builder    : String_Builder;
steam_api_bottom_builder : String_Builder;
singleton_top_builder    : String_Builder;
singleton_bottom_builder : String_Builder;
header_assigns_builder   : String_Builder;
header_loads_builder     : String_Builder;

procs_out             :: #bake_arguments print_to_builder(builder = *procs_builder);
types_out             :: #bake_arguments print_to_builder(builder = *types_builder);
steam_api_top_out     :: #bake_arguments print_to_builder(builder = *steam_api_top_builder);
steam_api_bottom_out  :: #bake_arguments print_to_builder(builder = *steam_api_bottom_builder);
singleton_top_out     :: #bake_arguments print_to_builder(builder = *singleton_top_builder);
singleton_bottom_out  :: #bake_arguments print_to_builder(builder = *singleton_bottom_builder);
header_assign_out     :: #bake_arguments print_to_builder(builder = *header_assigns_builder);
header_load_out       :: #bake_arguments print_to_builder(builder = *header_loads_builder);

current_namespace := "";


main :: () {
    init_string_builder(*procs_builder);
    init_string_builder(*types_builder);

    clear_output_folder();

    // flat procs
    file_data, success := read_entire_file(steam_api_flat);
    if !success {
        print("Failed to read %", steam_api_flat);
        exit(1);
    }

    print("Generating %...\n", output_procs_filename);
    convert_steam_api_flat(file_data);


    // flat types
    file_data, success = read_entire_file(steam_api_json);
    if !success {
        print("Failed to read %", steam_api_json);
        exit(1);
    }

    print("Generating %...\n", output_types_filename);
    convert_steam_api_json(file_data);


    write_entire_file(output_procs_filename, builder_to_string(*procs_builder));
    write_entire_file(output_types_filename, builder_to_string(*types_builder));


    // singletones
    init_string_builder(*steam_api_top_builder);
    init_string_builder(*steam_api_bottom_builder);
    init_string_builder(*singleton_top_builder);
    init_string_builder(*singleton_bottom_builder);
    init_string_builder(*header_assigns_builder);
    init_string_builder(*header_loads_builder);

    file_data, success = read_entire_file(output_procs_filename);
    if !success {
        print("Failed to read %", output_procs_filename);
        exit(1);
    }

    generate_classes(file_data);

    write_entire_file(output_assignments_filename, builder_to_string(*header_assigns_builder));
    write_entire_file(output_loads_filename, builder_to_string(*header_loads_builder));
}


convert_steam_api_flat :: (file_data: string) {
    out :: procs_out;

    rows := split(file_data, "\n");

    in_header := true;
    just_emit_newline := false;

    // steam_api_flat.h is autogenerated, therefor we make some assumptions
    // about parsing it.
    // a) Spaces only appear singly
    // b) Each comment section header is a singleton name
    // c) & and ** in parameters are always fully spaced

    for row, line_number: rows {
        if in_header {
            if starts_with(row, "//")
                continue;
            else
                in_header = false;
        }

        if starts_with(row, "#") continue;

        line := strip(row);

        if line == "" {
            if !just_emit_newline  out("\n");
            just_emit_newline = true;
            continue;
        }
        else
            just_emit_newline = false;

        if starts_with(line, "typedef") {
            // typedef old new; // comment
            parts := split(line, ";");
            types := split(parts[0], " ");
            types_out("% :: %;%\n", types[2], types[1], parts[1]);
        }
        else if starts_with(line, "//") {
            // // ClassName
            out("%\n", line);
            //out("% :: void;\n", split(line, " ")[1]);
        }
        else if starts_with(line, "S_API") {
            for replacements  line = replace(line, it.before, it.after);
            sections := split(line, "(");
            header := split(sections[0], " ");
            if header.count == 4 && header[2] != "*" || header.count > 4 {
                print("WTF on line %\n", line_number + 1);
            }
            return_type := header[1];
            return_is_pointer := false;
            proc_name := header[2];
            if proc_name == "*" {
                return_is_pointer = true;
                proc_name = header[3];
            }
            else if starts_with(proc_name, "*") {
                return_is_pointer = true;
                proc_name = slice(proc_name, 1, proc_name.count - 1);
            }

            return_char := ifx return_is_pointer  "*" else "";
            if return_type == "int"  return_type = "s32";

            parameters := split(split(sections[1], ")")[0], ",");

            out("% :: (", proc_name);

            for parameter, index: parameters {
                if index != 0  out(", ");
                parts := split(strip(parameter), " ");
                parameter_type := parts[0];
                parameter_name := parts[parts.count-1];
                pointer_char := "";
                if ends_with(parameter_type, "*") {
                    parameter_type = slice(parameter_type, 0, parameter_type.count-1);
                    pointer_char = "*";
                }
                else if parts.count == 3 {
                    if parts[1] == "*" || parts[1] == "&" // wing and prayer & -> *
                        pointer_char = "*";
                    else if parts[1] == "**"
                        pointer_char = "**";
                    else
                        print("WTF on line %\n", line_number + 1);
                }
                if parameter_type == "int"  parameter_type = "s32";

                out("%1: %2%3", parameter_name, pointer_char, parameter_type);
            }

            if return_type == "void"
                out(") #foreign steam;\n");
            else
                out(") -> %1%2 #foreign steam;\n", return_char, return_type);
        }

    }

    out("\n"); // make sure we have a blank line at bottom so that `generate_classes` has a sentinel
}


convert_steam_api_json :: (file_data: string) {
    root, success := json_parse_string(file_data);

    out :: types_out;

    traverse_node :: (key: string, node: JSON_Value, depth: int = 0) {
        const_name : JSON_Value;
        const_type : JSON_Value;
        const_val  : JSON_Value;
        success : bool;

        if node.type == {
        case .BOOLEAN;

        case .NUMBER;

        case .STRING;
            if key == {
                case "classname";
                out("% :: void;\n", node.value.str);
            }

        case .OBJECT;
            for node.value.object {
                traverse_node(it_index, it, depth + 1);
            }

        case .ARRAY;
            for node.value.array {
                traverse_node(key, it, depth + 1);
            }
            if key == {
                case "consts";
                if depth == 1 {
                    out("\n");
                    for node.value.array {
                        object := it.value.object;
                        const_name := get_str(object, "constname");
                        const_type := get_str(object, "consttype", type_replacements);
                        const_val  := get_str(object, "constval", const_val_replacements);
                        out("% : % : %;\n", const_name, const_type, const_val);
                    }
                }

                case "typedefs";
                if depth == 1 {
                    out("\n");
                    for node.value.array {
                        object := it.value.object;
                        typedef_before := get_str(object, "type");
                        typedef_after  := get_str(object, "typedef");
                        if contains(typedef_before, "(*)")
                            typedef_before = "*void";
                        else {
                            for typedef_replacements {
                                if typedef_before == it.before {
                                    typedef_before = it.after;
                                }
                            }
                        }
                        out("% :: %;\n", typedef_after, typedef_before);
                    }
                }

                case "enums";
                //if depth == 1 {
                    for node.value.array {
                        object := it.value.object;
                        enum_name := get_str(object, "enumname");
                        enum_values := get_array(object, "values");
                        //print("%\n", enum_values);
                        //print("A");
                        out("\n% :: enum s32 {\n", enum_name);
                        for enum_values {
                            object := it.value.object;
                            name := get_str(object, "name");
                            value := get_str(object, "value");
                            out("    % :: %;\n", name, value);
                        }
                        out("}\n");
                    }
                //}

                case "structs";
                if depth == 1 {
                    for node.value.array {
                        object := it.value.object;
                        struct_name := get_str(object, "struct");
                        struct_fields := get_array(object, "fields");
                        out("\n% :: struct {\n", struct_name);
                        for struct_fields {
                            object := it.value.object;
                            field_name := get_str(object, "fieldname");
                            field_type := get_str(object, "fieldtype", type_replacements);
                            if field_type == "int"  field_type = "s32";
                            if ends_with(field_type, "**")
                                field_type = sprint("**%", slice(field_type, 0, field_type.count - 2));
                            else if ends_with(field_type, "*")
                                field_type = sprint("*%", slice(field_type, 0, field_type.count - 1));
                            else if contains(field_type, "(*)")
                                field_type = "*void";
                            bracket := index_of_string(field_type, "[");
                            if bracket == -1
                                out("    % : %;\n", field_name, field_type);
                            else
                                out("    % : % %;\n", field_name,
                                                        slice(field_type, bracket, field_type.count - bracket),
                                                        slice(field_type, 0, bracket));
                        }
                        out("}\n");
                    }
                }

                case "callback_structs";
                if depth == 1 {
                    for node.value.array {
                        object := it.value.object;
                        struct_name := get_str(object, "struct");
                        struct_fields := get_array(object, "fields");
                        out("\n% :: struct {\n", struct_name);
                        for struct_fields {
                            object := it.value.object;
                            field_name := get_str(object, "fieldname");
                            field_type := get_str(object, "fieldtype", type_replacements);
                            if field_type == "int"  field_type = "s32";
                            coloncolon := index_of_string(field_type, "::");
                            if coloncolon != -1  field_type = slice(field_type, coloncolon + 2, field_type.count - (coloncolon + 2));
                            if ends_with(field_type, "**")
                                field_type = sprint("**%", slice(field_type, 0, field_type.count - 2));
                            else if ends_with(field_type, "*")
                                field_type = sprint("*%", slice(field_type, 0, field_type.count - 1));
                            else if contains(field_type, "(*)")
                                field_type = "*void";
                            bracket := index_of_string(field_type, "[");
                            if bracket == -1
                                out("    % : %;\n", field_name, field_type);
                            else
                                out("    % : % %;\n", field_name,
                                                        slice(field_type, bracket, field_type.count - bracket),
                                                        slice(field_type, 0, bracket));
                        }
                        out("}\n");
                    }
                }
            }
        }
    }

    root_value : JSON_Value;
    traverse_node("", root);
}


get_str :: (object: *JSON_Object, key: string) -> string {
    value, success := table_find(<<object, key);
    if success  return value.value.str;
    else        return "";
}


get_str :: (object: *JSON_Object, key: string, replacements: [] Replacement) -> string {
    value, success := table_find(<<object, key);
    if success  {
        s := value.value.str;
        for replacements  s = replace(s, it.before, it.after);
        return s;
    }
    else
        return "";
}


get_obj :: (object: *JSON_Object, key: string) -> *JSON_Object {
    value, success := table_find(<<object, key);
    if success  return value.value.object;
    else        return null;
}


get_array :: (object: *JSON_Object, key: string) -> [..]JSON_Value {
    value, success := table_find(<<object, key);
    return value.value.array;
}


generate_classes :: (file_data: string) {
    rows := split(file_data, "\n");

    in_section            := false;
    section_name          := "";
    in_singleton          := false;
    past_singleton_header := false;
    singleton_instance    := "";
    namespace             := "";
    singleton_count       := 0;

    header_assign_out("do_assign :: () {\n");

    steam_api_instance :: "steam_api";

    steam_api_header :: #string ___JAI
SteamAPI : SteamAPI_Namespace;


#scope_file


SteamAPI_Namespace :: struct {
    // procs
    ___JAI

    steam_api_top_out(steam_api_header);

    for raw_row, line_number: rows {
        row := strip(raw_row);

        if !in_section {
            if starts_with(row, "//") {
                in_section = true;
                section_name = strip(mid(row, 3));
                if section_name == "ISteamClient" {
                    in_singleton = true;
                    past_singleton_header = true;
                    singleton_instance, namespace = write_header(section_name);
                    print("Generating %.jai...\n", singleton_instance);
                }
            }
        }
        else {
            if row == "" {
                if in_singleton {
                    singleton_top_out("}\n");
                    singleton_count += 1;
                    append(*singleton_top_builder, builder_to_string(*singleton_bottom_builder));
                    write_entire_file(sprint("%/%.jai", output_autogen_folder, singleton_instance), builder_to_string(*singleton_top_builder));
                }

                in_section = false;
                in_singleton = false;
                past_singleton_header = false;
                reset(*singleton_top_builder);
                reset(*singleton_bottom_builder);
                continue;
            }

            if !past_singleton_header {
                i := index_of_string(row, "_v");
                if i >= 0 {
                    c := row[i + 2];
                    if c >= #char "0" || c <= #char "9" {
                        first_row := false;
                        if !in_singleton {
                            first_row = true;
                            singleton_instance, namespace = write_header(section_name);
                            print("Generating %.jai...\n", singleton_instance);
                        }
                        in_singleton = true;
                        name := mid(row, 9, i);
                        name = snake_from_camel(name);
                        defer free(name);

                        space_at := index_of_string(row, " ");
                        call := mid(row, 0, space_at);
                        header_assign_out("    %", name);
                        for name.count..40  header_assign_out(" ");
                        header_assign_out("= %();\n", call);
                        header_load_out("#load \"%.jai\";\n", singleton_instance);

                        continue;
                    }
                }
            }

            past_singleton_header = true;

            if in_singleton {
                short_name, long_name, flat_name, parameters, returns, return_is_string := singleton_parts_from_flat(row);

                singleton_top_out("    %", short_name);
                for short_name.count..50  singleton_top_out(" ");
                singleton_top_out(":: %;\n", long_name);

                singleton_bottom_out("\n\n");
                if returns == "" {
                    singleton_bottom_out("% :: inline (%) {\n", long_name, parameters);
                    if parameters == ""
                        singleton_bottom_out("    %(%);\n", flat_name, singleton_instance);
                    else
                        singleton_bottom_out("    %(%, %);\n", flat_name, singleton_instance, strip_types(parameters));
                }
                else {
                    singleton_bottom_out("% :: inline (%) -> % {\n", long_name, parameters, returns);
                    prefix, postfix : string;
                    if return_is_string {
                        prefix = "to_string(";
                        postfix = ")";
                    }
                    if parameters == ""
                        singleton_bottom_out("    return %1%2(%3)%4;\n", prefix, flat_name, singleton_instance, postfix);
                    else
                        singleton_bottom_out("    return %1%2(%3, %4)%5;\n", prefix, flat_name, singleton_instance, strip_types(parameters), postfix);
                }
                singleton_bottom_out("}\n");
            }
            else {
                short_name, long_name, flat_name, parameters, returns, return_is_string := steam_api_parts_from_flat(row);

                steam_api_top_out("    %", long_name);
                for long_name.count..60  steam_api_top_out(" ");
                steam_api_top_out(":: %;\n", long_name);

                steam_api_bottom_out("\n\n");
                if returns == "" {
                    steam_api_bottom_out("% :: inline (%) {\n", long_name, parameters);
                    if parameters == ""
                        steam_api_bottom_out("    %(%);\n", flat_name, steam_api_instance);
                    else
                        steam_api_bottom_out("    %(%, %);\n", flat_name, steam_api_instance, strip_types(parameters));
                }
                else {
                    prefix, postfix : string;
                    if return_is_string {
                        prefix = "to_string(";
                        postfix = ")";
                    }
                    steam_api_bottom_out("% :: inline (%) -> % {\n", long_name, parameters, returns);
                    if parameters == ""
                        steam_api_bottom_out("    return %1%2(%3)%4;\n", prefix, flat_name, steam_api_instance, postfix);
                    else
                        steam_api_bottom_out("    return %1%2(%3, %4)%5;\n", prefix, flat_name, steam_api_instance, strip_types(parameters), postfix);
                }
                steam_api_bottom_out("}\n");
            }
        }
    }

    header_assign_out("}\n");

    steam_api_top_out("}\n");
    append(*steam_api_top_builder, builder_to_string(*steam_api_bottom_builder));
    write_entire_file(output_steam_api_filename, builder_to_string(*steam_api_top_builder));

    // @TODO assert(singleton_count == N)  make sure new versions don't add singletones that we don't know about it `steam.jai`
    // @TODO assert version in `steam_client_header.jai` matches version in `isteamclient.h`
}


write_header :: (class_name: string) -> string, string {
    namespace := mid(class_name, 1);
    instance := snake_from_camel(namespace);

    header :: #string ___JAI
%1 : *%2;
%3 : %3_Namespace;


#scope_file


%3_Namespace :: struct {
    // procs
    ___JAI

    singleton_top_out(header, instance, class_name, namespace);

    return instance, namespace;
}


strip_types :: (str: string) -> string {
    builder: String_Builder;
    init_string_builder(*builder);
    defer reset(*builder);

    skip_next := false;
    skipping := false;
    for i: 0..str.count - 1 {
        if skip_next {
            skip_next = false;
            continue;
        }

        if skipping {
            if str[i] == #char "," {
                skipping = false;
                append(*builder, str[i]);
            }
        }
        else {
            if str[i] == #char ":" {
                skipping = true;
                skip_next = true;
            }
            else {
                append(*builder, str[i]);
            }
        }
    }

    return builder_to_string(*builder);
}


singleton_parts_from_flat :: (row: string) -> short_name: string, long_name: string, flat_name: string, parameters: string, returns: string, return_is_string: bool {
    return_is_string := false;

    _1 :: 9;
    _2 := _1 + 1;

    forward_til(row, #char "_", #code _2);

    i := _2 + 1;
    forward_til(row, #char " ", #code i);

    short_name := mid(row, _2 + 1, i);
    long_name  := mid(row, _1 + 1, i);
    flat_name  := mid(row,  0,     i);

    forward_til(row, #char "(", #code i);
    forward_til(row, #char ",", #char ")", #code i);

    parameters : string = ---;
    returns : string = ---;

    if row[i] == #char ")" {
        parameters = "";
        returns_at := last_index_of_string(row, "->");
        if returns_at == -1
            returns = "";
        else {
            returns_at += 3;
            returns = mid(row, returns_at, row.count - 16);
        }
    }
    else {
        parameters_start := i + 1;
        if row[parameters_start] == #char " "  parameters_start += 1;
        last_char := last_index_of_string(row, "->");
        if last_char == -1 {
            last_char = last_index_of_string(row, ")");
            parameters = mid(row, parameters_start, last_char);
            returns = "";
        }
        else {
            last_char -= 2;
            parameters = mid(row, parameters_start, last_char);
            returns = mid(row, last_char + 5, row.count - 16);
        }
    }

    if returns == "*char" {
        return_is_string = true;
        returns = "string";
    }

    return short_name, long_name, flat_name, parameters, returns, return_is_string;
}


steam_api_parts_from_flat :: (row: string) -> short_name: string, long_name: string, flat_name: string, parameters: string, returns: string, return_is_string: bool {
    return_is_string := false;

    _1 :: 9;
    _2 := _1 + 1;

    forward_til(row, #char "_", #code _2);

    i := _2 + 1;
    forward_til(row, #char " ", #code i);

    short_name := mid(row, _2 + 1, i);
    long_name  := mid(row, _1, i);
    if starts_with(long_name, "ISteam") {
        long_name.data += 1;
        long_name.count -= 1;
    }
    flat_name  := mid(row,  0,     i);

    forward_til(row, #char "(", #code i);
    forward_til(row, #char ",", #char ")", #code i);

    parameters : string = ---;
    returns : string = ---;

    if row[i] == #char ")" {
        parameters = "";
        returns_at := last_index_of_string(row, "->");
        if returns_at == -1
            returns = "";
        else {
            returns_at += 3;
            returns = mid(row, returns_at, row.count - 16);
        }
    }
    else {
        parameters_start := i + 1;
        if row[parameters_start] == #char " "  parameters_start += 1;
        last_char := last_index_of_string(row, "->");
        if last_char == -1 {
            last_char = last_index_of_string(row, ")");
            parameters = mid(row, parameters_start, last_char);
            returns = "";
        }
        else {
            last_char -= 2;
            parameters = mid(row, parameters_start, last_char);
            returns = mid(row, last_char + 5, row.count - 16);
        }
    }

    if returns == "*char" {
        return_is_string = true;
        returns = "string";
    }

    return short_name, long_name, flat_name, parameters, returns, return_is_string;
}



clear_output_folder :: () {
    proc :: (info: *File_Visit_Info, user_data: *void) {
        file_delete(info.full_name);
    }

    visit_files(output_autogen_folder, recursive=false, null, proc, visit_files=true, visit_directories=false);
}
